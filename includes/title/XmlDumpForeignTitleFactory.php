<?php
/**
 * A codec for %MediaWiki page titles.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 * http://www.gnu.org/copyleft/gpl.html
 *
 * @file
 * @license GPL 2+
 */

/**
 * A parser that handles page titles from %MediaWiki XML dump data.
 */
class XmlDumpForeignTitleFactory {
	/**
	 * @var array|null
	 */
	protected $foreignNamespaces;
	/**
	 * @var array|null
	 */
	private $foreignNamespacesFlipped;

	/**
	 * @param array|null $foreignNamespaces An array 'id' => 'name' of the data
	 * under siteinfo/namespaces in the XML dump, or null if no such data is
	 * available
	 */
	public function __construct( $foreignNamespaces ) {
		$this->foreignNamespaces = $foreignNamespaces;
		if ( !is_null( $foreignNamespaces ) ) {
			$this->foreignNamespacesFlipped = array_flip( $foreignNamespaces );
		}
	}

	/**
	 * Creates a ForeignTitle object based on the <title> and <ns> attributes and
	 * the list of namespaces found in the exported XML dump.
	 *
	 * Although exported XML dumps have contained a map of namespace IDs to names
	 * since MW 1.5, the importer used to completely ignore the <siteinfo> tag
	 * before MW 1.25.  It is therefore possible that custom XML dumps (i.e. not
	 * generated by Special:Export) have been created without this metadata, and
	 * it would be a retrograde step if these simply stopped working in current
	 * versions.  As a result, this code falls back to using namespace data for
	 * the local wiki (similar to buggy pre-1.25 behaviour) if
	 * $this->foreignNamespaces is empty.
	 *
	 * @param string $title The <title> element from the XML
	 * @param string|null $ns The <ns> element from the XML, or null if no such
	 * element is present
	 * @return ForeignTitle
	 */
	public function createForeignTitle( $title, $ns ) {
		// Export schema version 0.5 and earlier (MW 1.18 and earlier) does not
		// contain a <ns> tag, so we need to be able to handle that case.
		if ( is_null( $ns ) ) {
			return self::parseTitleNoNs( $title );
		} else {
			return self::parseTitleWithNs( $title, $ns );
		}
	}

	/**
	 * Used in parseTitle where we don't know the namespace ID (MW 1.18 and
	 * earlier).
	 *
	 * @param string $title
	 * @return ForeignTitle
	 */
	protected function parseTitleNoNs( $title ) {
		global $wgContLang;
		$pieces = explode( ':', $title, 2 );

		// Does the part before the colon match a known namespace? Check the
		// foreign namespaces if we know about them, or if not, use the local
		// wiki's namespace names to resolve this -- better than nothing, and
		// mimics old crappy behavior
		$isNamespacePartValid = is_null( $this->foreignNamespaces ) ?
			( $wgContLang->getNsIndex( $pieces[0] ) !== false ) :
			isset( $this->foreignNamespacesFlipped[$pieces[0]] );

		if ( count( $pieces ) === 2 && $isNamespacePartValid ) {
			list( $namespaceName, $pageName ) = $pieces;
		} else {
			$namespaceName = '';
			$pageName = $title;
		}

		$ns = is_null( $this->foreignNamespaces ) ?
			null :
			$this->foreignNamespacesFlipped[$namespaceName];

		return new ForeignTitle( $ns, $namespaceName, $pageName );
	}

	/**
	 * Used in parseTitle where we do know the namespace ID.
	 *
	 * @param string $title
	 * @param int $ns
	 * @return ForeignTitle
	 */
	protected function parseTitleWithNs( $title, $ns ) {
		$pieces = explode( ':', $title, 2 );

		if (
			is_null( $this->foreignNamespaces ) ||
			!isset( $this->foreignNamespaces[$ns] )
		) {
			// We assume that the portion of the page title before the colon is the
			// namespace name, except in the case of namespace 0
			if ( count( $pieces ) === 2 && $ns != '0' ) {
				list( $namespaceName, $pageName ) = $pieces;
			} else {
				$namespaceName = '';
				$pageName = $title;
			}
		} else {
			// Use the namespace name corresponding to the given ID. If we're not in
			// the main namespace, we ignore the portion of the page title before the
			// colon, as it may be an alias or alternative name for the namespace
			$namespaceName = $this->foreignNamespaces[$ns];
			// Make sure we're not in the main namespace, where the colon is
			// semantically meaningless
			if ( count( $pieces ) === 2 && $namespaceName !== "" ) {
				$pageName = $pieces[1];
			} else {
				$pageName = $title;
			}
		}

		return new ForeignTitle( $ns, $namespaceName, $pageName );
	}
}
