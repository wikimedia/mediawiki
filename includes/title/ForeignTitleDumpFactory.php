<?php
/**
 * A codec for %MediaWiki page titles.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 * http://www.gnu.org/copyleft/gpl.html
 *
 * @file
 * @license GPL 2+
 */

/**
 * A parser that handles page titles from %MediaWiki XML dump data.
 */
class ForeignTitleDumpFactory {
	/**
	 * @var array|null
	 */
	protected $foreignNamespaces;

	/**
	 * @param array|null $foreignNamespaces An array 'id' => 'name' of the data
	 * under siteinfo/namespaces in the XML dump, or null if no such data is
	 * available
	 */
	public function __construct( $foreignNamespaces ) {
		$this->foreignNamespaces = $foreignNamespaces;
	}

	/**
	 * Creates a ForeignTitle object based on the <title> and <ns> attributes and
	 * the list of namespaces found in the exported XML dump.
	 *
	 * Although exported XML dumps have contained a map of namespace IDs to names
	 * since MW 1.5, the importer used to completely ignore the <siteinfo> tag
	 * before MW 1.25.  It is therefore possible that custom XML dumps (i.e. not
	 * generated by Special:Export) have been created without this metadata, and
	 * it would be a retrograde step if these simply stopped working in current
	 * versions.  As a result, this code falls back to using namespace data for
	 * the local wiki (similar to buggy pre-1.25 behaviour) if
	 * $this->foreignNamespaces is empty.
	 *
	 * @param string $title The <title> element from the XML
	 * @param string|null $ns The <ns> element from the XML, or null if no such
	 * element is present
	 * @return ForeignTitle
	 */
	public function createForeignTitle( $title, $ns ) {
		// Export schema version 0.5 and earlier (MW 1.18 and earlier) does not
		// contain a <ns> tag, so we need to be able to handle that case.
		if ( is_null( $ns ) ) {
			return self::parseTitleNoNs( $title );
		} else {
			return self::parseTitleWithNs( $title, $ns );
		}
	}
		/**
	 * Used in parseTitle where we don't know the namespace ID (MW 1.18 and
	 * earlier).
	 *
	 * @param string $title
	 * @return ForeignTitle
	 */
	protected function parseTitleNoNs( $title ) {
		global $wgContLang;
		$pieces = explode( ':', $title, 2 );

		if ( is_null( $this->foreignNamespaces ) ) {
			// We don't know much, so we just use the local wiki's namespace names
			// to resolve this. Better than nothing, and mimics old crappy behavior
			if ( count( $pieces ) === 2 &&
					$wgContLang->getNsIndex( $pieces[0] ) !== false ) {
				$namespaceName = $pieces[0];
				$pageName = $pieces[1];
			} else {
				$namespaceName = '';
				$pageName = $title;
			}
			$ns = null;
		} else {
			// Does the part before the colon match a known foreign namespace?
			if ( count( $pieces ) === 2 &&
					in_array( $pieces[0], $this->foreignNamespaces ) ) {
				$namespaceName = $pieces[0];
				$pageName = $pieces[1];
			} else {
				// Colon is semantically meaningless
				$namespaceName = '';
				$pageName = $title;
			}
			$ns = array_search( $namespaceName, $this->foreignNamespaces );
		}

		return new ForeignTitle( $ns, $namespaceName, $pageName );
	}

	/**
	 * Used in parseTitle where we do know the namespace ID.
	 *
	 * @param string $title
	 * @param int $ns
	 * @return ForeignTitle
	 */
	protected function parseTitleWithNs( $title, $ns ) {
		$pieces = explode( ':', $title, 2 );

		if ( is_null( $this->foreignNamespaces ) ) {
			if ( $ns == '0' ) {
				$namespaceName = '';
				$pageName = $title;
			} else {
				list( $namespaceName, $pageName ) = $pieces;
			}
		} else {
			$namespaceName = $this->foreignNamespaces[$ns];
			// Make sure we're not in the main namespace, where the colon is
			// semantically meaningless
			if ( count( $pieces ) === 2 && $namespaceName !== "" ) {
				$pageName = $pieces[1];
			} else {
				$pageName = $title;
			}
		}

		return new ForeignTitle( $ns, $namespaceName, $pageName );
	}
}
