<?php
/**
 * A structure to hold the title of a page on a foreign MediaWiki installation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 * http://www.gnu.org/copyleft/gpl.html
 *
 * @file
 * @author This, that and the other
 */

/**
 * A simple, immutable structure to hold the title of a page on a foreign
 * MediaWiki installation.
 */
class ForeignTitle {
	/** @var int */
	private $namespaceId;
	/** @var string */
	private $namespaceName;
	/** @var string */
	private $pageName;

	/**
	 * @param int $namespaceId
	 * @param string $namespaceName
	 * @param string $pageName
	 */
	protected function __construct( $namespaceId, $namespaceName, $pageName ) {
		$this->namespaceId = intval( $namespaceId );
		$this->namespaceName = $namespaceName;
		$this->pageName = $pageName;
	}

	/**
	 * Creates a ForeignTitle object based on the <title> and <ns> attributes
	 * and the list of namespaces found in the exported XML dump.
	 *
	 * Although exported XML dumps have contained a map of namespace IDs to names
	 * since MW 1.5, the importer used to completely ignore the <siteinfo> tag
	 * before MW 1.24.  It is therefore possible that custom XML dumps (i.e. not
	 * generated by Special:Export) have been created without this metadata, and
	 * it would be a retrograde step if these simply stopped working in current
	 * versions.  As a result, this code falls back to using namespace data for
	 * the local wiki (similar to buggy pre-1.24 behaviour) if $foreignNamespaces
	 * is empty.
	 *
	 * @param string $title The <title> element from the XML
	 * @param string|null $ns The <ns> element from the XML, or null if no such
	 * element is present
	 * @param array|null $foreignNamespaces An array 'id' => 'name' of the data
	 * under siteinfo/namespaces in the XML dump, or null if no such data is
	 * available
	 * @return ForeignTitle
	 */
	public static function newFromXmlData( $title, $ns, $foreignNamespaces ) {
		// Export schema version 0.5 and earlier (MW 1.18 and earlier) does not
		// contain a <ns> tag, so we need to be able to handle that case.
		if ( is_null( $ns ) ) {
			return self::newFromXmlDataNoNs( $title, $foreignNamespaces );
		} else {
			return self::newFromXmlDataWithNs( $title, $ns, $foreignNamespaces );
		}
	}

	/**
	 * Used in newFromXmlData where we don't know the namespace ID (MW 1.18 and
	 * earlier).
	 *
	 * @param string $title
	 * @param array|null $foreignNamespaces
	 * @return ForeignTitle
	 */
	protected static function newFromXmlDataNoNs( $title, $foreignNamespaces ) {
		global $wgContLang;
		$pieces = explode( ':', $title, 2 );

		if ( is_null( $foreignNamespaces ) ) {
			// We don't know much, so we just use the local wiki's namespace names
			// to resolve this. Better than nothing, and mimics old crappy behavior
			if ( count( $pieces ) === 2 &&
					$wgContLang->getNsIndex( $pieces[0] ) !== false ) {
				$namespaceName = $pieces[0];
				$pageName = $pieces[1];
			} else {
				$namespaceName = '';
				$pageName = $title;
			}
			$ns = $wgContLang->getNsIndex( $pieces[0] ) || 0;
		} else {
			// Does the part before the colon match a known foreign namespace?
			if ( count( $pieces ) === 2 &&
					in_array( $pieces[0], $foreignNamespaces ) ) {
				$namespaceName = $pieces[0];
				$pageName = $pieces[1];
			} else {
				// Colon is semantically meaningless
				$namespaceName = '';
				$pageName = $title;
			}
			$ns = array_search( $namespaceName, $foreignNamespaces );
		}

		return new ForeignTitle( $ns, $namespaceName, $pageName );
	}

	/**
	 * Used in newFromXmlData where we do know the namespace ID.
	 *
	 * @param string $title
	 * @param int $ns
	 * @param array|null $foreignNamespaces
	 * @return ForeignTitle
	 */
	protected static function newFromXmlDataWithNs( $title, $ns,	
			$foreignNamespaces ) {
		$pieces = explode( ':', $title, 2 );

		if ( is_null( $foreignNamespaces ) ) {
			if ( $ns == '0' ) {
				$namespaceName = '';
				$pageName = $title;
			} else {
				list( $namespaceName, $pageName ) = $pieces;
			}
		} else {
			$namespaceName = $foreignNamespaces[$ns];
			// Make sure we're not in the main namespace, where the colon is
			// semantically meaningless
			if ( count( $pieces ) === 2 && $namespaceName !== "" ) {
				$pageName = $pieces[1];
			} else {
				$pageName = $title;
			}
		}

		return new ForeignTitle( $ns, $namespaceName, $pageName );
	}

	/** @return int */
	public function getNamespaceId() {
		return $this->namespaceId;
	}

	/** @return string */
	public function getNamespaceName() {
		return $this->namespaceName;
	}

	/** @return string */
	public function getPageName() {
		return $this->pageName;
	}

	/** @return string */
	public function getFullText() {
		$result = '';
		if ( $this->namespaceName ) {
			$result .= $this->namespaceName . ':';
		}
		$result .= $this->pageName;
		return $result;
	}

	/**
	 * Determines which local title best corresponds to the foreign title. If
	 * such a title can't be found or would be locally invalid, null is returned.
	 *
	 * @param int|null $targetNs The target namespace, or null to smartly choose
	 * the target namespace
	 * @return Title|null
	 */
	public function toLocalTitle( $targetNs = null ) {
		if ( is_null( $targetNs ) ) {
			$targetNs = $this->namespaceId;
		}

		if ( MWNamespace::exists( $targetNs ) ) {
			# We have a matching namespace ID locally, so put the page there
			return Title::makeTitleSafe( $targetNs, $this->pageName );
		} else {
			# Try for a matching local namespace name
			$targetNs = $wgContLang->getNsIndex( $this->namespaceName );
			if ( $targetNs !== false ) {
				return Title::makeTitleSafe( $targetNs, $this->pageName );
			} else {
				# Just fall back to main namespace
				return Title::makeTitleSafe( 0, $this->getFullText() );
			}
		}
	}
}
