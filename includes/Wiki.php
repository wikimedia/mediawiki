<?php
/**
 * MediaWiki is the to-be base class for this whole project
 *
 * @internal documentation reviewed 15 Mar 2010
 */
class MediaWiki extends ContextSource {

	public function request( WebRequest $x = null ){
		return wfSetVar( $this->getRequest(), $x );
	}

	public function output( OutputPage $x = null ){
		return wfSetVar( $this->getOutput(), $x );
	}

	public function __construct( RequestContext $context ){
		$this->setContext( $context );
		$this->getContext()->setTitle( $this->parseTitle() );
	}

	/**
	 * Parse $request to get the Title object
	 *
	 * @return Title object to be $wgTitle
	 */
	private function parseTitle() {
		global $wgContLang;

		$curid = $this->getRequest()->getInt( 'curid' );
		$title = $this->getRequest()->getVal( 'title' );

		if ( $this->getRequest()->getCheck( 'search' ) ) {
			// Compatibility with old search URLs which didn't use Special:Search
			// Just check for presence here, so blank requests still
			// show the search page when using ugly URLs (bug 8054).
			$ret = SpecialPage::getTitleFor( 'Search' );
		} elseif ( $curid ) {
			// URLs like this are generated by RC, because rc_title isn't always accurate
			$ret = Title::newFromID( $curid );
		} elseif ( $title == '' && $this->getAction() != 'delete' ) {
			$ret = Title::newMainPage();
		} else {
			$ret = Title::newFromURL( $title );
			// check variant links so that interwiki links don't have to worry
			// about the possible different language variants
			if ( count( $wgContLang->getVariants() ) > 1 && !is_null( $ret ) && $ret->getArticleID() == 0 ){
				$wgContLang->findVariantLink( $title, $ret );
			}
		}
		// For non-special titles, check for implicit titles
		if ( is_null( $ret ) || $ret->getNamespace() != NS_SPECIAL ) {
			// We can have urls with just ?diff=,?oldid= or even just ?diff=
			$oldid = $this->getRequest()->getInt( 'oldid' );
			$oldid = $oldid ? $oldid : $this->getRequest()->getInt( 'diff' );
			// Allow oldid to override a changed or missing title
			if ( $oldid ) {
				$rev = Revision::newFromId( $oldid );
				$ret = $rev ? $rev->getTitle() : $ret;
			}
		}

		if( $ret === null || ( $ret->getDBkey() == '' && $ret->getInterwiki() == '' ) ){
			$ret = new BadTitle;
		}
		return $ret;
	}

	/**
	 * Get the Title object that we'll be acting on, as specified in the WebRequest
	 * @return Title
	 */
	public function getTitle(){
		if( $this->getContext()->getTitle() === null ){
			$this->getContext()->setTitle( $this->parseTitle() );
		}
		return $this->getContext()->getTitle();
	}

	/**
	 * Performs the request.
	 * - bad titles
	 * - read restriction
	 * - local interwiki redirects
	 * - redirect loop
	 * - special pages
	 * - normal pages
	 *
	 * @return Article object
	 */
	public function performRequest() {
		global $wgServer, $wgUsePathInfo;

		wfProfileIn( __METHOD__ );

		if ( $this->getRequest()->getVal( 'printable' ) === 'yes' ) {
			$this->getOutput()->setPrintable();
		}

		wfRunHooks( 'BeforeInitialize', array(
			$this->getTitle(),
			null,
			$this->getOutput(),
			$this->getUser(),
			$this->getRequest(),
			$this
		) );

		// Invalid titles. Bug 21776: The interwikis must redirect even if the page name is empty.
		if ( $this->getTitle() instanceof BadTitle ) {
			throw new ErrorPageError( 'badtitle', 'badtitletext' );
		// If the user is not logged in, the Namespace:title of the article must be in
		// the Read array in order for the user to see it. (We have to check here to
		// catch special pages etc. We check again in Article::view())
		} else if ( !$this->getTitle()->userCanRead() ) {
			$this->getOutput()->loginToUse();
		// Interwiki redirects
		} else if ( $this->getTitle()->getInterwiki() != '' ) {
			$rdfrom = $this->getRequest()->getVal( 'rdfrom' );
			if ( $rdfrom ) {
				$url = $this->getTitle()->getFullURL( 'rdfrom=' . urlencode( $rdfrom ) );
			} else {
				$query = $this->getRequest()->getValues();
				unset( $query['title'] );
				$url = $this->getTitle()->getFullURL( $query );
			}
			// Check for a redirect loop
			if ( !preg_match( '/^' . preg_quote( $wgServer, '/' ) . '/', $url ) && $this->getTitle()->isLocal() ) {
				// 301 so google et al report the target as the actual url.
				$this->getOutput()->redirect( $url, 301 );
			} else {
				$this->getContext()->setTitle( new BadTitle );
				wfProfileOut( __METHOD__ );
				throw new ErrorPageError( 'badtitle', 'badtitletext' );
			}
		// Redirect loops, no title in URL, $wgUsePathInfo URLs, and URLs with a variant
		} else if ( $this->getRequest()->getVal( 'action', 'view' ) == 'view' && !$this->getRequest()->wasPosted()
			&& ( $this->getRequest()->getVal( 'title' ) === null || $this->getTitle()->getPrefixedDBKey() != $this->getRequest()->getVal( 'title' ) )
			&& !count( array_diff( array_keys( $this->getRequest()->getValues() ), array( 'action', 'title' ) ) ) )
		{
			if ( $this->getTitle()->getNamespace() == NS_SPECIAL ) {
				list( $name, $subpage ) = SpecialPageFactory::resolveAlias( $this->getTitle()->getDBkey() );
				if ( $name ) {
					$this->getContext()->setTitle( SpecialPage::getTitleFor( $name, $subpage ) );
				}
			}
			$targetUrl = $this->getTitle()->getFullURL();
			// Redirect to canonical url, make it a 301 to allow caching
			if ( $targetUrl == $this->getRequest()->getFullRequestURL() ) {
				$message = "Redirect loop detected!\n\n" .
					"This means the wiki got confused about what page was " .
					"requested; this sometimes happens when moving a wiki " .
					"to a new server or changing the server configuration.\n\n";

				if ( $wgUsePathInfo ) {
					$message .= "The wiki is trying to interpret the page " .
						"title from the URL path portion (PATH_INFO), which " .
						"sometimes fails depending on the web server. Try " .
						"setting \"\$wgUsePathInfo = false;\" in your " .
						"LocalSettings.php, or check that \$wgArticlePath " .
						"is correct.";
				} else {
					$message .= "Your web server was detected as possibly not " .
						"supporting URL path components (PATH_INFO) correctly; " .
						"check your LocalSettings.php for a customized " .
						"\$wgArticlePath setting and/or toggle \$wgUsePathInfo " .
						"to true.";
				}
				wfHttpError( 500, "Internal error", $message );
			} else {
				$this->getOutput()->setSquidMaxage( 1200 );
				$this->getOutput()->redirect( $targetUrl, '301' );
			}
		// Special pages
		} else if ( NS_SPECIAL == $this->getTitle()->getNamespace() ) {
			// actions that need to be made when we have a special pages
			SpecialPageFactory::executePath( $this->getTitle(), $this->getContext() );
		} else {
			// ...otherwise treat it as an article view. The article
			// may be a redirect to another article or URL.
			$article = $this->initializeArticle();
			if ( is_object( $article ) ) {
				$this->performAction( $article );
				wfProfileOut( __METHOD__ );
				return $article;
			} elseif ( is_string( $article ) ) {
				$this->getOutput()->redirect( $article );
			} else {
				wfProfileOut( __METHOD__ );
				throw new MWException( "Shouldn't happen: MediaWiki::initializeArticle() returned neither an object nor a URL" );
			}
		}
		wfProfileOut( __METHOD__ );
	}

	/**
	 * Create an Article object of the appropriate class for the given page.
	 *
	 * @deprecated in 1.19; use Article::newFromTitle() instead
	 * @param $title Title
	 * @param $context RequestContext
	 * @return Article object
	 */
	public static function articleFromTitle( $title, RequestContext $context ) {
		return Article::newFromTitle( $title, $context );
	}

	/**
	 * Returns the action that will be executed, not necesserly the one passed
	 * passed through the "action" parameter. Actions disabled in
	 * $wgDisabledActions will be replaced by "nosuchaction"
	 *
	 * @return String: action
	 */
	public function getAction() {
		global $wgDisabledActions;

		$action = $this->getRequest()->getVal( 'action', 'view' );

		// Check for disabled actions
		if ( in_array( $action, $wgDisabledActions ) ) {
			return 'nosuchaction';
		}

		// Workaround for bug #20966: inability of IE to provide an action dependent
		// on which submit button is clicked.
		if ( $action === 'historysubmit' ) {
			if ( $this->getRequest()->getBool( 'revisiondelete' ) ) {
				return 'revisiondelete';
			} else {
				return 'view';
			}
		} elseif ( $action == 'editredlink' ) {
			return 'edit';
		}

		return $action;
	}

	/**
	 * Initialize the main Article object for "standard" actions (view, etc)
	 * Create an Article object for the page, following redirects if needed.
	 *
	 * @return mixed an Article, or a string to redirect to another URL
	 */
	private function initializeArticle() {
		global $wgDisableHardRedirects;

		wfProfileIn( __METHOD__ );

		$action = $this->getRequest()->getVal( 'action', 'view' );
		$article = Article::newFromTitle( $this->getTitle(), $this->getContext() );
		// NS_MEDIAWIKI has no redirects.
		// It is also used for CSS/JS, so performance matters here...
		if ( $this->getTitle()->getNamespace() == NS_MEDIAWIKI ) {
			wfProfileOut( __METHOD__ );
			return $article;
		}
		// Namespace might change when using redirects
		// Check for redirects ...
		$file = ( $this->getTitle()->getNamespace() == NS_FILE ) ? $article->getFile() : null;
		if ( ( $action == 'view' || $action == 'render' ) 	// ... for actions that show content
			&& !$this->getRequest()->getVal( 'oldid' ) &&    // ... and are not old revisions
			!$this->getRequest()->getVal( 'diff' ) &&    // ... and not when showing diff
			$this->getRequest()->getVal( 'redirect' ) != 'no' &&	// ... unless explicitly told not to
			// ... and the article is not a non-redirect image page with associated file
			!( is_object( $file ) && $file->exists() && !$file->getRedirected() ) )
		{
			// Give extensions a change to ignore/handle redirects as needed
			$ignoreRedirect = $target = false;

			wfRunHooks( 'InitializeArticleMaybeRedirect',
				array( $this->getTitle(), $this->getRequest(), &$ignoreRedirect, &$target, &$article ) );

			// Follow redirects only for... redirects.
			// If $target is set, then a hook wanted to redirect.
			if ( !$ignoreRedirect && ( $target || $article->isRedirect() ) ) {
				// Is the target already set by an extension?
				$target = $target ? $target : $article->followRedirect();
				if ( is_string( $target ) ) {
					if ( !$wgDisableHardRedirects ) {
						// we'll need to redirect
						wfProfileOut( __METHOD__ );
						return $target;
					}
				}
				if ( is_object( $target ) ) {
					// Rewrite environment to redirected article
					$rarticle = Article::newFromTitle( $target, $this->getContext() );
					$rarticle->loadPageData();
					if ( $rarticle->exists() || ( is_object( $file ) && !$file->isLocal() ) ) {
						$rarticle->setRedirectedFrom( $this->getTitle() );
						$article = $rarticle;
						$this->getContext()->setTitle( $target );
					}
				}
			} else {
				$this->getContext()->setTitle( $article->getTitle() );
			}
		}
		wfProfileOut( __METHOD__ );
		return $article;
	}

	/**
	 * Cleaning up request by doing deferred updates, DB transaction, and the output
	 */
	public function finalCleanup() {
		wfProfileIn( __METHOD__ );
		// Now commit any transactions, so that unreported errors after
		// output() don't roll back the whole DB transaction
		$factory = wfGetLBFactory();
		$factory->commitMasterChanges();
		// Output everything!
		$this->getOutput()->output();
		// Do any deferred jobs
		wfDoUpdates( 'commit' );

		$this->doJobs();
		wfProfileOut( __METHOD__ );
	}

	/**
	 * Do a job from the job queue
	 */
	private function doJobs() {
		global $wgJobRunRate;

		if ( $wgJobRunRate <= 0 || wfReadOnly() ) {
			return;
		}
		if ( $wgJobRunRate < 1 ) {
			$max = mt_getrandmax();
			if ( mt_rand( 0, $max ) > $max * $wgJobRunRate ) {
				return;
			}
			$n = 1;
		} else {
			$n = intval( $wgJobRunRate );
		}
		
		// Close the session so that jobs don't access the current session
		$this->shutdownLBFactory();
		session_write_close();

		while ( $n-- && false != ( $job = Job::pop() ) ) {
			$output = $job->toString() . "\n";
			$t = -wfTime();
			$success = $job->run();
			$t += wfTime();
			$t = round( $t * 1000 );
			if ( !$success ) {
				$output .= "Error: " . $job->getLastError() . ", Time: $t ms\n";
			} else {
				$output .= "Success, Time: $t ms\n";
			}
			wfDebugLog( 'jobqueue', $output );
		}
	}

	/**
	 * Ends this task peacefully
	 */
	public function restInPeace() {
		MessageCache::logMessages();
		wfLogProfilingData();
		$this->shutdownLBFactory();
		wfDebug( "Request ended normally\n" );
	}

	/**
	 * Commit pending master changes, shutdown the current loadbalancer 
	 * factory and destroys the factory instance.
	 */
	private function shutdownLBFactory() {
		// Commit and close up!
		$factory = LBFactory::singleton();
		$factory->commitMasterChanges();
		$factory->shutdown();
		LBFactory::destroyInstance();
	}

	/**
	 * Perform one of the "standard" actions
	 *
	 * @param $article Article
	 */
	private function performAction( $article ) {
		global $wgSquidMaxage, $wgUseExternalEditor;

		wfProfileIn( __METHOD__ );

		if ( !wfRunHooks( 'MediaWikiPerformAction', array(
				$this->getOutput(), $article, $this->getTitle(),
				$this->getUser(), $this->getRequest(), $this ) ) )
		{
			wfProfileOut( __METHOD__ );
			return;
		}

		$act = $this->getAction();

		$action = Action::factory( $act, $article );
		if( $action instanceof Action ){
			$action->show();
			wfProfileOut( __METHOD__ );
			return;
		}

		switch( $act ) {
			case 'view':
				$this->getOutput()->setSquidMaxage( $wgSquidMaxage );
				$article->view();
				break;
			case 'raw': // includes JS/CSS
				wfProfileIn( __METHOD__ . '-raw' );
				$raw = new RawPage( $article );
				$raw->view();
				wfProfileOut( __METHOD__ . '-raw' );
				break;
			case 'delete':
			case 'revert':
			case 'rollback':
			case 'protect':
			case 'unprotect':
			case 'info':
			case 'markpatrolled':
			case 'render':
			case 'deletetrackback':
				$article->$act();
				break;
			case 'submit':
				if ( session_id() == '' ) {
					// Send a cookie so anons get talk message notifications
					wfSetupSession();
				}
				// Continue...
			case 'edit':
				if ( wfRunHooks( 'CustomEditor', array( $article, $this->getUser() ) ) ) {
					$internal = $this->getRequest()->getVal( 'internaledit' );
					$external = $this->getRequest()->getVal( 'externaledit' );
					$section = $this->getRequest()->getVal( 'section' );
					$oldid = $this->getRequest()->getVal( 'oldid' );
					if ( !$wgUseExternalEditor || $act == 'submit' || $internal ||
					   $section || $oldid || ( !$this->getUser()->getOption( 'externaleditor' ) && !$external ) ) {
						$editor = new EditPage( $article );
						$editor->submit();
					} elseif ( $wgUseExternalEditor && ( $external || $this->getUser()->getOption( 'externaleditor' ) ) ) {
						$mode = $this->getRequest()->getVal( 'mode' );
						$extedit = new ExternalEdit( $article, $mode );
						$extedit->edit();
					}
				}
				break;
			case 'history':
				if ( $this->getRequest()->getFullRequestURL() == $this->getTitle()->getInternalURL( 'action=history' ) ) {
					$this->getOutput()->setSquidMaxage( $wgSquidMaxage );
				}
				$history = new HistoryPage( $article );
				$history->history();
				break;
			case 'revisiondelete':
				// For show/hide submission from history page
				$special = SpecialPageFactory::getPage( 'Revisiondelete' );
				$special->execute( '' );
				break;
			default:
				if ( wfRunHooks( 'UnknownAction', array( $act, $article ) ) ) {
					$this->getOutput()->showErrorPage( 'nosuchaction', 'nosuchactiontext' );
				}
		}
		wfProfileOut( __METHOD__ );
	}
}
