<?php
/**
 * Content object implementation for representing flat text.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 * http://www.gnu.org/copyleft/gpl.html
 *
 * @since 1.21
 *
 * @file
 * @ingroup Content
 *
 * @author Daniel Kinzler
 */

/**
 * Content object implementation for representing flat text.
 *
 * TextContent instances are immutable
 *
 * @ingroup Content
 */
class TextContent extends AbstractContent {

	/**
	 * @param string $text
	 * @param string $model_id
	 */
	public function __construct( $text, $model_id = CONTENT_MODEL_TEXT ) {
		parent::__construct( $model_id );

		if ( $text === null || $text === false ) {
			wfWarn( "TextContent constructed with \$text = " . var_export( $text, true ) . "! "
				. "This may indicate an error in the caller's scope.", 2 );

			$text = '';
		}

		if ( !is_string( $text ) ) {
			throw new MWException( "TextContent expects a string in the constructor." );
		}

		$this->mText = $text;
	}

	/**
	 * @note Mutable subclasses MUST override this to return a copy!
	 *
	 * @return Content $this
	 */
	public function copy() {
		return $this; # NOTE: this is ok since TextContent are immutable.
	}

	public function getTextForSummary( $maxlength = 250 ) {
		global $wgContLang;

		$text = $this->getNativeData();

		$truncatedtext = $wgContLang->truncate(
			preg_replace( "/[\n\r]/", ' ', $text ),
			max( 0, $maxlength ) );

		return $truncatedtext;
	}

	/**
	 * Returns the text's size in bytes.
	 *
	 * @return int
	 */
	public function getSize() {
		$text = $this->getNativeData();

		return strlen( $text );
	}

	/**
	 * Returns true if this content is not a redirect, and $wgArticleCountMethod
	 * is "any".
	 *
	 * @param bool $hasLinks If it is known whether this content contains links,
	 * provide this information here, to avoid redundant parsing to find out.
	 *
	 * @return bool
	 */
	public function isCountable( $hasLinks = null ) {
		global $wgArticleCountMethod;

		if ( $this->isRedirect() ) {
			return false;
		}

		if ( $wgArticleCountMethod === 'any' ) {
			return true;
		}

		return false;
	}

	/**
	 * Returns the text represented by this Content object, as a string.
	 *
	 * @return string The raw text.
	 */
	public function getNativeData() {
		$text = $this->mText;

		return $text;
	}

	/**
	 * Returns the text represented by this Content object, as a string.
	 *
	 * @return string The raw text.
	 */
	public function getTextForSearchIndex() {
		return $this->getNativeData();
	}

	/**
	 * Returns attempts to convert this content object to wikitext,
	 * and then returns the text string. The conversion may be lossy.
	 *
	 * @note: the parser will prefer the HTML returned by getHtmlForTransclusion()
	 *
	 * @return string|bool The raw text, or false if the conversion failed.
	 */
	public function getWikitextForTransclusion() {
		$wikitext = $this->convert( CONTENT_MODEL_WIKITEXT, 'lossy' );

		if ( $wikitext ) {
			return $wikitext->getNativeData();
		} else {
			return false;
		}
	}

	/**
	 * Returns the HTML generated by getHtml().
	 *
	 * @note: This allows text based content to be included in wikitext pages
	 * without that content being processed as wikitext.
	 *
	 * @return string HTML
	 */
	public function getHtmlForTransclusion() {
		return $this->getHtml();
	}

	/**
	 * Returns a Content object with pre-save transformations applied.
	 * This implementation just trims trailing whitespace.
	 *
	 * @param Title $title
	 * @param User $user
	 * @param ParserOptions $popts
	 *
	 * @return Content
	 */
	public function preSaveTransform( Title $title, User $user, ParserOptions $popts ) {
		$text = $this->getNativeData();
		$pst = rtrim( $text );

		return ( $text === $pst ) ? $this : new static( $pst );
	}

	/**
	 * Diff this content object with another content object.
	 *
	 * @since 1.21
	 *
	 * @param Content $that The other content object to compare this content object to.
	 * @param Language $lang The language object to use for text segmentation.
	 *    If not given, $wgContentLang is used.
	 *
	 * @return Diff A diff representing the changes that would have to be
	 *    made to this content object to make it equal to $that.
	 */
	public function diff( Content $that, Language $lang = null ) {
		global $wgContLang;

		$this->checkModelID( $that->getModel() );

		// @todo could implement this in DifferenceEngine and just delegate here?

		if ( !$lang ) {
			$lang = $wgContLang;
		}

		$otext = $this->getNativeData();
		$ntext = $that->getNativeData();

		# Note: Use native PHP diff, external engines don't give us abstract output
		$ota = explode( "\n", $lang->segmentForDiff( $otext ) );
		$nta = explode( "\n", $lang->segmentForDiff( $ntext ) );

		$diff = new Diff( $ota, $nta );

		return $diff;
	}

	/**
	 * Fills the provided ParserOutput object with information derived from the content.
	 * Unless $generateHtml was false, this includes an HTML representation of the content
	 * provided by getHtml().
	 *
	 * For content models listed in $wgTextModelsToParse, this method will call the MediaWiki
	 * wikitext parser on the text to extract any (wikitext) links, magic words, etc.
	 *
	 * Subclasses may override this to provide custom content processing.
	 * For custom HTML generation alone, it is sufficient to override getHtml().
	 *
	 * @param Title $title Context title for parsing
	 * @param int $revId Revision ID (for {{REVISIONID}})
	 * @param ParserOptions $options Parser options
	 * @param bool $generateHtml Whether or not to generate HTML
	 * @param ParserOutput $output The output object to fill (reference).
	 */
	protected function fillParserOutput( Title $title, $revId,
		ParserOptions $options, $generateHtml, ParserOutput &$output
	) {
		global $wgParser, $wgTextModelsToParse;

		if ( in_array( $this->getModel(), $wgTextModelsToParse ) ) {
			// Parse just to get links etc into the database, HTML is replaced by
			// the parent implementation of fillParserOutput called below.
			$output = $wgParser->parse( $this->getNativeData(), $title, $options, true, true, $revId );
		}

		parent::fillParserOutput( $title, $revId, $options, $generateHtml, $output );
	}

	/**
	 * @see TextContent::getHtml()
	 *
	 * Subclasses may override this to provide a custom HTML rendering, e.g. by parsing markup.
	 *
	 * For backwards-compatibility, this default implementation just calls getHighlightHtml(),
	 * which returns an HTML escaped version of the raw text content.
	 *
	 * @return string An HTML representation of the content
	 */
	protected function getHtml() {
		return $this->getHighlightHtml();
	}

	/**
	 * Generates an HTML version of the content, for display.
	 *
	 * This default implementation returns an HTML-escaped version
	 * of the raw text content.
	 *
	 * @note: The functionality of this method should really be implemented
	 * in getHtml(), and subclasses should override getHtml() if needed.
	 * getHighlightHtml() is kept around for backward compatibility with
	 * extensions that already override it.
	 *
	 * @deprecated since 1.24. Use getHtml() instead. In particular, subclasses overriding
	 *     getHighlightHtml() should override getHtml() instead.
	 *
	 * @return string An HTML representation of the content
	 */
	protected function getHighlightHtml() {
		return htmlspecialchars( $this->getNativeData() );
	}

	/**
	 * @see Content::getContentForTransclusion
	 * @see AbstractContent::getContentForTransclusion
	 *
	 * Overwrites the default behavior of calling convert() for the case that
	 * the target model is CONTENT_MODEL_WIKITEXT in order to disable direct
	 * conversion to wikitext in favor of HTML based transclusion.
	 *
	 * @note When transcluding other text-based content to wikitext,
	 * we want to go via that content's HTML rendering, rather than
	 * using the naive conversion implemented by convert().
	 * AbstractContent::getTextForTransclusion will used HTML based
	 * transclusion if getContentForTransclusion() returns false with
	 * CONTENT_MODEL_WIKITEXT.
	 *
	 * @since 1.24
	 *
	 * @param string $modelId
	 * @param object|null $context
	 *
	 * @return Content|false
	 */
	public function getContentForTransclusion( $modelId, $context = null ) {
		$content = false;

		if ( $modelId === $this->getModel() ) {
			// Shortcut for the case that no conversion is needed.
			// Needed to avoid the "go via HTML" preference for
			// standard wikitext-in-wikitext transclusion.
			$content = $this;
		} else if ( $modelId === CONTENT_MODEL_WIKITEXT ) {
			// NOTE: when transcluding other text-based content to wikitext,
			// we want to go via that content's HTML rendering, rather than
			// using the naive conversion implemented by convert().
			$content = $this->convertContentViaHtml( $modelId, $context );
		}

		if ( !$content ) {
			// XXX: we may want to prevent inclusion of CSS into JS, etc.
			// But transclusion of JS code into plain text should still be supported.
			$content = parent::getContentForTransclusion( $modelId );
		}

		return $content;
	}

	/**
	 * This implementation provides lossless conversion between content models based
	 * on TextContent.
	 *
	 * @param string $toModel The desired content model, use the CONTENT_MODEL_XXX flags.
	 * @param string $lossy Flag, set to "lossy" to allow lossy conversion. If lossy conversion is not
	 *     allowed, full round-trip conversion is expected to work without losing information.
	 *
	 * @return Content|bool A content object with the content model $toModel, or false if that
	 *     conversion is not supported.
	 *
	 * @see Content::convert()
	 */
	public function convert( $toModel, $lossy = '' ) {
		$converted = parent::convert( $toModel, $lossy );

		if ( $converted !== false ) {
			return $converted;
		}

		$toHandler = ContentHandler::getForModelID( $toModel );

		if ( $toHandler instanceof TextContentHandler ) {
			// NOTE: ignore content serialization format - it's just text anyway.
			$text = $this->getNativeData();
			$converted = $toHandler->unserializeContent( $text );
		}

		return $converted;
	}

}
